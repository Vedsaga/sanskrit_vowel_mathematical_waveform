/**
 * Shape Engine - Core shape generation using in-phase radial modulation
 * 
 * This module implements the mathematical foundation for frequency-to-shape
 * visualization using the formula: r(θ) = R + A·sin((fq-1)·θ + φ)
 * 
 * The number of wiggles in a shape equals (fq - 1), where fq is the frequency.
 */

import type { Point, ValidationResult } from './types';

/**
 * Generates points for a frequency shape using in-phase radial modulation.
 * 
 * Formula: r(θ) = R + A·sin((fq-1)·θ + φ)
 * Cartesian: x = r·cos(θ), y = r·sin(θ)
 * 
 * @param fq - Frequency value (integer ≥ 1)
 * @param R - Base radius
 * @param A - Wiggle amplitude (must be < R)
 * @param phi - Phase offset for rotation (radians)
 * @param resolution - Number of sample points (360-2048)
 * @returns Array of {x, y} points forming the shape
 */
export function generateShapePoints(
  fq: number,
  R: number,
  A: number,
  phi: number,
  resolution: number
): Point[] {
  const points: Point[] = [];
  const wiggleCount = fq - 1;
  
  for (let i = 0; i <= resolution; i++) {
    // θ ranges from 0 to 2π
    const theta = (i / resolution) * 2 * Math.PI;
    
    // r(θ) = R + A·sin((fq-1)·θ + φ)
    const r = R + A * Math.sin(wiggleCount * theta + phi);
    
    // Convert polar to Cartesian coordinates
    const x = r * Math.cos(theta);
    const y = r * Math.sin(theta);
    
    points.push({ x, y });
  }
  
  return points;
}

/**
 * Validates shape parameters according to the specification.
 * 
 * Validation rules:
 * - fq must be an integer ≥ 1
 * - A must be < R (to prevent radius inversion)
 * - resolution must be between 360 and 2048
 * - R must be positive
 * - A must be non-negative
 * 
 * @param fq - Frequency value
 * @param R - Base radius
 * @param A - Wiggle amplitude
 * @param resolution - Number of sample points
 * @returns ValidationResult with valid flag and error messages
 */
export function validateShapeParams(
  fq: number,
  R: number,
  A: number,
  resolution: number
): ValidationResult {
  const errors: string[] = [];
  
  // Validate fq: must be integer ≥ 1
  if (typeof fq !== 'number' || !Number.isFinite(fq)) {
    errors.push('Frequency must be a valid number');
  } else if (!Number.isInteger(fq)) {
    errors.push('Frequency must be an integer');
  } else if (fq < 1) {
    errors.push('Frequency must be at least 1');
  }
  
  // Validate R: must be positive
  if (typeof R !== 'number' || !Number.isFinite(R)) {
    errors.push('Base radius must be a valid number');
  } else if (R <= 0) {
    errors.push('Base radius must be positive');
  }
  
  // Validate A: must be non-negative and < R
  if (typeof A !== 'number' || !Number.isFinite(A)) {
    errors.push('Wiggle amplitude must be a valid number');
  } else if (A < 0) {
    errors.push('Wiggle amplitude must be non-negative');
  } else if (typeof R === 'number' && R > 0 && A >= R) {
    errors.push('Wiggle amplitude must be less than base radius');
  }
  
  // Validate resolution: must be between 360 and 2048
  if (typeof resolution !== 'number' || !Number.isFinite(resolution)) {
    errors.push('Resolution must be a valid number');
  } else if (!Number.isInteger(resolution)) {
    errors.push('Resolution must be an integer');
  } else if (resolution < 360 || resolution > 2048) {
    errors.push('Resolution must be between 360 and 2048');
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
}

/**
 * Counts the number of wiggles (local maxima) in a shape's radius function.
 * 
 * A wiggle is defined as a local maximum in the radius function r(θ).
 * For a shape with frequency fq, there should be exactly (fq - 1) wiggles.
 * 
 * This function verifies the wiggle count by detecting transitions from
 * increasing to decreasing radius (sign changes in the derivative).
 * 
 * @param points - Array of points generated by generateShapePoints
 * @returns Number of wiggles (local maxima) detected
 */
export function countWiggles(points: Point[]): number {
  if (points.length < 3) {
    return 0;
  }
  
  // Calculate radius for each point (distance from origin)
  const radii = points.map(p => Math.sqrt(p.x * p.x + p.y * p.y));
  
  // Calculate the range of radii to determine if there's meaningful variation
  const minRadius = Math.min(...radii);
  const maxRadius = Math.max(...radii);
  const radiusRange = maxRadius - minRadius;
  
  // If the radius variation is negligible (essentially a circle), return 0 wiggles
  // Use a threshold relative to the average radius to handle floating-point precision
  const avgRadius = (minRadius + maxRadius) / 2;
  const threshold = avgRadius * 1e-10;
  
  if (radiusRange < threshold) {
    return 0;
  }
  
  let wiggleCount = 0;
  
  // Track whether radius is increasing or decreasing
  // We count a wiggle when we transition from increasing to decreasing
  let wasIncreasing: boolean | null = null;
  
  // Iterate through points (excluding the duplicate last point)
  for (let i = 1; i < radii.length - 1; i++) {
    const diff = radii[i] - radii[i - 1];
    
    // Skip very small differences (floating-point noise)
    if (Math.abs(diff) < radiusRange * 1e-10) {
      continue;
    }
    
    const isIncreasing = diff > 0;
    
    // Count transition from increasing to decreasing (local maximum)
    if (wasIncreasing === true && !isIncreasing) {
      wiggleCount++;
    }
    
    wasIncreasing = isIncreasing;
  }
  
  // Handle wrap-around: check if there's a maximum at the boundary
  // Compare the trend at the end with the trend at the beginning
  if (radii.length > 2) {
    const lastDiff = radii[radii.length - 2] - radii[radii.length - 3];
    const firstDiff = radii[1] - radii[0];
    
    // If ending with increase and starting with decrease, there's a maximum at boundary
    if (lastDiff > radiusRange * 1e-10 && firstDiff < -radiusRange * 1e-10) {
      wiggleCount++;
    }
  }
  
  return wiggleCount;
}

/**
 * Validates a frequency input value.
 * 
 * @param value - The value to validate (can be any type)
 * @returns ValidationResult indicating if the value is a valid frequency
 */
export function validateFrequencyInput(value: unknown): ValidationResult {
  const errors: string[] = [];
  
  if (value === null || value === undefined || value === '') {
    errors.push('Frequency is required');
    return { valid: false, errors };
  }
  
  const num = typeof value === 'number' ? value : Number(value);
  
  if (!Number.isFinite(num)) {
    errors.push('Frequency must be a valid number');
  } else if (!Number.isInteger(num)) {
    errors.push('Frequency must be an integer');
  } else if (num < 1) {
    errors.push('Frequency must be at least 1');
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
}
